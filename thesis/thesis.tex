\documentclass[BTech]{iitmdiss}

\usepackage{epstopdf}
\usepackage{times}
\usepackage{epsf}
\usepackage{threeparttable}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{txfonts,pxfonts,amsfonts}
\usepackage{epsfig}
\usepackage{caption}
\usepackage{subfig}
\usepackage[dvips]{graphicx}
% \usepackage[square,numbers,sort]{natbib}
\usepackage[square]{natbib}
\usepackage[hypertex]{hyperref} % hyperlinks for references.
% \usepackage{algorithmic}
\usepackage{program}


%\include{commands}

% Strut macros for skipping spaces above and below text in tables. 
\def\abovestrut#1{\rule[0in]{0in}{#1}\ignorespaces}
\def\belowstrut#1{\rule[-#1]{0in}{#1}\ignorespaces}

\def\abovespace{\abovestrut{0.20in }}
\def\aroundspace{\abovestrut{0.20in}\belowstrut{0.10in}}
\def\belowspace{\belowstrut{0.10in}}
%%%%%%%%%%%%%%%%%%%%%%%%%


\def\thesistitle{The Maximum-Flow problem in undirected graphs}
\def\thesisauthor{Karthik Abinav S}


\begin{document}
\bibliographystyle{iitm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% Title page

\title{\thesistitle}

\author{\thesisauthor}

\date{May 2014}
\department{Computer Science and Engineering}

%\nocite{*}
\begin{singlespace}
\maketitle 
\end{singlespace} 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Certificate
\certificate

\vspace*{0.5in}

\noindent This is to certify that the thesis entitled {\bf {\thesistitle}}, 
submitted by {\bf {\thesisauthor}}, to the Indian Institute of Technology, 
Madras, for the award of the degree of {\bf Bachelor of Technology}, 
is a bona fide record of the research work carried out by him under my
supervision. The contents of this thesis, in full or in parts, have not been
submitted to any other Institute or University for the award of any degree or
diploma.

\vspace*{1.4in}
\hspace*{-0.25in}
\begin{singlespace}
\noindent {\bf Dr.~N.~S.~Narayanaswamy } \\
\noindent Research Guide \\ 
\noindent Associate Professor \\
\noindent Dept. of Computer Science and Engineering\\
\noindent IIT-Madras, 600 036 \\
\end{singlespace}
\vspace*{0.20in}
\noindent Place: Chennai\\ 
Date:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Acknowledgements
\acknowledgements

Acknoledgements

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abstract

\abstract

\noindent KEYWORDS: \hspace*{0.5em} \parbox[t]{4.4in}{Graph Theory,
Maximum Flow, Laplacian solvers }

\vspace*{24pt}

Maximum flow problem has been a very important optimization problem in computer science and mathematics. This problem has a lot of practical relevance.
Some of the age-old applications involving maximum flow have been in electrical circuits, water supply networks, etc. With the advent of social media
and social networks, this problem has found a newer practical relevance. And since the graphs in these networks are typically very large,
researchers are sought after creating faster and more efficient algorithms for this problem. \\

Some of the classical algorithms to solve this problem are the Ford-Fulkerson's augmenting path algorithm and the Dinic's Algorithm. These algorithms
compute the exact value of the maximum flow. It is also fairly straightforward to obtain the optimal flow vector after the termination of the
algorithm. The main drawback with this algorithm is that the running time, though polynomial, is very high and is expensive to use in many practical
situations. Following these algorithms a series of algorithms based on push-relabel and blocking flow techniques were devised which had a slightly better running time as compared to the 
classical algorithms. The series of algorithms terminated with the algorithm by Goldberg-Rao which gave a O($\min(n^{\frac{2}{3}},m^{\frac{1}{2}}) \log(\frac{n^2}{m}) \log U$)-time algorithm
for edge capacities in $\{1,2,\ldots,U\}$. For 
extremely large graphs, as in the case of social networks, this algorithm is still far from being practical. \\

In 2008, the breakthrough result by Spielman and Teng gave an algorithm to solve the Symetric Diagonally Dominant(SDD) system of equations in 
near-linear time. This work was immediately extended by Koutis-Miller-Peng which gave an efficient algorithm to produce an incremental graph sparsifier.
Development of these techniques led to the development of an almost linear time algorithm to the maximum flow problem by Cristiano-Kelner-Madry-Spielman-Teng.
This involved looking at the graph as a resistive network, approximating the electrical flow and producing an approximate s-t flow from this approximate
electrical flow. This algorithm broke the running time barrier of Golderg-Rao and gave the first almost-linear time algorithm. \\

In this thesis, we give a survey of the above algorithms for the maximum flow problem. We first start off by giving a brief description of the 
classical algorithms. We then conclude this by giving a completely recursive specification for the push-relabel algorithm.
We then present the required tools from spectral graph theory and linear algebra that is required to understand the almost linear 
time algorithm. Finally, we present the Cristiano-Kelner-Madry-Spielman-Teng algorithm in detail. We will also present some of the key theorems from the 
Koutis-Miller-Peng SDD solver. Finally, we give some arguments to justify the requirement of the weight updates and also show some steps that can possibly
lead to making the algorithm parallel.\\

\pagebreak
% \listoftables
% \addcontentsline{toc}{chapter}{LIST OF TABLES}
% \listoffigures


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Table of contents etc.

\begin{singlespace}
\tableofcontents
\thispagestyle{empty}

% \listoftables
% \addcontentsline{toc}{chapter}{LIST OF TABLES}
 \listoffigures
 \addcontentsline{toc}{chapter}{LIST OF FIGURES}
\end{singlespace}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abbreviations
\abbreviations
 
\noindent 
\begin{tabbing}
 xxxxxxxxxxx \= xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \kill
\textbf{IITM}   \> Indian Institute of Technology, Madras \\
\textbf{BFS} \> Breadth First Search \\
\textbf{DFS} \> Depth First Search \\
\textbf{SDD} \> Symmetric Diagonally Dominant \\
\end{tabbing}

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Notation

 \chapter*{\centerline{NOTATION}}
 \addcontentsline{toc}{chapter}{NOTATION}
 
 \begin{singlespace}
 \begin{tabbing}
 xxxxxxxxxxx \= xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \kill
 \textbf{$m$}  \> The number of edges in a graph G \\
 
 \textbf{$n$} \> The number of vertices in a graph G \\
 
 \textbf{$u$}  \> A $m \ast 1$ matrix containing the capacities of the edges \\
 
 \textbf{$U$}  \> This defines the ratio between the highest and lowest capacity in the graph, i.e.\\
		  \hspace{25mm}$\frac{\displaystyle\max_e u_e}{\displaystyle\min_e u_e}$ \\
 
 \end{tabbing}
 \end{singlespace}
 
 \pagebreak
 \clearpage

%The main text will follow from this point so set the page numbering
%to arabic from here on.
\pagenumbering{arabic}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction.

 \chapter{INTRODUCTION}
 \label{chap:intro}
    Maximum-Flow problem is an age old optimization problem in mathematics and computer science. Hundreds of researchers have investigated this problem
    and have given some interesting results. This problem has far-reaching applications in almost every field of engineering and sciences. Hence, this 
    problem is of great importance, not just theoretically, but also in real-world applications. Devising better and more efficient algorithms
    for this problem and its variants has always been the pursuit. Inspite, of having had so much research into this problem, for many years we were far from getting an algorithm
    that runs in time that is good for practical purposes. This gives an indication of the hardness of this problem.
    
    \section{Basics}
      \subsubsection{Graph}
      A \textit{graph} G($V$, $E$, $\rho$) is defined as a mathematical structure on the set of vertices $V$ and the set of edges $E$ and an adjacency
      function $\rho : V \times V \rightarrow E$, such that $\rho(a,b) = e$ for $a,b \in V$ and $e \in E$ tells that there exists an edge $e$ between 
      the vertices $a$ and $b$.
      
      \subsubsection{Undirected Graph}
	An \textit{undirected graph} is a graph where the function $\rho$ is symmetric, i.e. $\rho(a,b) = \rho(b,a)$.
 
      \subsubsection{Directed Graph}
	An \textit{directed graph} is a graph where the function $\rho$ is not necessarily a symmetric function.
	
      \subsubsection{Capacitated Graph}
	A \textit{capacitated graph} is a graph defined as G($V$, $E$, $\rho$, $\psi$), where the first three values in the tuple mean the same as before.
	The $\psi$ in the definition is a function $\psi: E \rightarrow \mathbb{R}$, which assigns a real number corresponding to every edge $e$ in the 
	graph. This real number is called the \textit{capacity} of the graph.
      
      \subsubsection{s-t Flow}
	A \textit{s-t flow} is a vector $f \in \mathbb{R}^{|E|}$ such that the following two criteria hold:
	\begin{itemize}
	 \item 
	   Flow Conservation: $$\displaystyle\sum_{e \in E^+(v)} f(e)- \displaystyle\sum_{e \in E^-(v)} f(e) = 0 ~~~~~ \forall v \in V \setminus \{s,t\}$$
	   where $E^-(v)$ denotes the set $\{a: \rho(a,v) \text{ is defined}\}$ and $E^+(v)$ denotes the set $\{a: \rho(v,a) \text{ is defined}\}$
	 \item
	  Capacity maintenance:
	    $$f(e) \leq \psi(e)~~~~~\forall e \in E$$
	      
	\end{itemize}
	
	Additionally, the \textit{value} of the flow $f$ is a real number $F$ such that,
	$$|f| = F = \displaystyle\sum_{e \in E^+(s)} f(e)- \displaystyle\sum_{e \in E^-(s)} f(e)$$
	
      \subsubsection{s-t Cut}
	A \textit{s-t cut} is defined as a partition of the vertex set $V$ into $U_1$ and $U_2$ such that, $s \in U_1$ and $t \in U_2$ and the vertices
	in $V \setminus \{U_1, U_2 \}$ is present exactly in one of $U_1$ and $U_2$.
      
      \subsubsection{Minimum s-t Cut Problem}
	Given a weighted graph G, let $\phi(\{U_1,U_2\})$ denote the sum of weights of edges such that one of its endpoints is in $U_1$ and the other
	end point is in $U_2$. The \textit{minimum s-t cut problem} is to select that cut, among all possible s-t cuts, whose value of $\phi$ is minimized.
      \section{Maximum Flow Problem}
	Given a capacitated graph G($V$, $E$, $\rho$, $\psi$), a source vertex s and a sink vertex t, the goal of the problem is to find a s-t flow
	such that the value of the flow is maximized among all possible s-t flows. \\
	
	\subsection{Simple Linear Program definition}
	  This problem can be posed as a linear programming problem. The first observation is that since LP's are efficiently solvable in polynomial
	  time, this will already give us a polynomial time algorithm. Though, this is helpful, this is not the main goal. The dual to the linear
	  program has a specific interpretation in graph theory. Hence, one can devise potentially more faster algorithms by using some primal-dual
	  methods.
	  
	  $$\max \displaystyle\sum_{u:(s,u) \in E} f((s,u))$$
	  subject to
	  \begin{itemize}
	   \item
	      $\forall v \in V \setminus \{s,t\}$ $\displaystyle\sum_{(u,v) \in E} f((u,v))$ = $\displaystyle\sum_{(v,w) \in E} f((v,w))$
	   \item
	      $\forall (u,v) \in E$ $f((u,v)) \leq c((u,v))$
	   \item
	      $\forall(u,v) \in E$ $f((u,v)) \geq 0$
	      
	  \end{itemize}
	  
	  Note that a tuple (a, b) represents an edge e whose end points are a and b. \\
	  
	  Clearly, the vector $f \in \mathbb{R}^{|E|}$ forms the set of variables in this LP. The constraints are given to ensure that the set of 
	  solutions are the set of valid s-t flows. hence, a constraint on the flow conservation on f and the capacity maintenance on f. Hence, for the
	  given problem instance, the number of variables are polynomial in $|E|$ and $|V|$ and the number of constraints are also polynomial in $|E|$
	  and $|V|$. \\
	  
	  Sometimes, an alternative formulation of the LP is given for this problem. 
	  $$ \max \displaystyle\sum_{i \in P} f(i) - \lambda (\displaystyle\sum_{v \in V} F(v)) $$
	  subject to:
	  
	  \begin{itemize}
	   \item 
	      $\forall (j,k) \in E$  $\gamma((j,k)) \leq c((j,k))$
	   \item
	      $\forall i \in P$, 
		$$f(i) \leq \gamma((j,k))~~~~~\forall (j,k) \in i$$
	   \item
	      $\forall v \in V$,
	      $$F(v) = \displaystyle\sum_{(j,k) \in E_{in}} \gamma((j,k)) - \displaystyle\sum_{(j,k) \in E_{out}} \gamma((j,k))$$
	   \item
	      $f \succeq 0$ , $F \succeq 0$, $\gamma \succeq 0$, $\lambda \geq 0$
	  \end{itemize}
	  
	  Here, $f$ is a vector from $\mathbb{R}^{|P|}$, where $|P|$ is the number of s-t paths in the graph. $F$ is a vector from $\mathbb{R}^{|V|}$
	  and $\gamma$ is a vector from $\mathbb{R}^{|E|}$. $f(i)$ denotes the flow that goes through the path $i$. $F(v)$ denotes the flow that 
	  is accumulated in the vertex v and $\gamma((i,j))$ denotes the flow that flows through the edge $(i,j)$. \\
	  
	  Clearly, the number of variables and the number of constraints are both exponential. Hence, we can't really hope to solve this in polynomial
	  time. The only advantage of this formulation is that a optimal solution to this LP, helps one visualize the amount of flow that goes through
	  each path independently. This formulation helps understanding of some of the path augmenting algorithms easier.
	
	\subsection{Dual of the Maximum Flow LP}
	  The dual to the maximum flow LP has a very interesting connection to graph theory. In fact, as observed ahead, the dual is a relaxation 
	  to the \textit{Minimum Cut Problem}. \\
	  
	  $$\min \displaystyle\sum_{(u,v) \in E} c((u,v)) \ast y((u,v))$$
	  
	  subject to:
	  \begin{itemize}
	   \item 
	    $\displaystyle \sum_{(u,v) \in p} y((u,v)) \geq 1~~~~~~\forall p \in P$
	   \item
	    $y((u,v)) \geq 0 ~~~~~~~~~~ \forall (u,v) \in E$
	   
	  \end{itemize}

	  Here, $y$ is the dual vector corresponding to the constraints in the primal. Hence, $y \in \mathbb{R}^{|E|}$. Here $P$ is the set of all
	  s-t paths in the graph. \\
	  
	  From the constraints, we can now interpret this dual as the relaxation to the s-t minimum cut problem. The vector y can be interpreted 
	  as the weight assigned to each edge in the graph. For every s-t path, the sum of edge weights in that path should be atleast one. And the 
	  objective is to minimize the weighted sum of these edge weights given by the vector $y$. Hence, one optimal solution to this above LP
	  will consist of assigning a weight of 1 to the edge with minimum $c$ in every s-t path and 0 to the other edges. This, in fact, gives the 
	  value of the minimum s-t cut in the graph and the edge with weights 1 forms the edge across the cut. \\
	  
	  Now, consider the following randomized rounding procedure to find a cut $(U_1, U_2)$ such that $\phi((U_1, U_2)) \leq OBJ$ where OBJ is 
	  the value of the objective for the dual, for a given vector $y$. \\
	  
	  Let the values given by the vector $y$ be weights of the edge. Now, consider any shortest path from s to v, and let d(v) be that 
	  shortest distance for vertex v. Choose a value of $h$ uniformly at random from $[0,1)$. Consider the set 
	  $R = \{v:d(v) \leq h\}$. Clearly, from the constraints above, corresponding to any feasible solution to the dual, $t$ will not be contained 
	  in the set $R$ and $s$ will be contained in the set $R$. Hence, $R$ forms a valid s-t cut. \\
	  
	  From linearity of expectation, we get
	  $$\mathbb{E}[\phi(R)] = \displaystyle\sum_{(i,j) \in E} c((i,j)) \mathbb{P}[i \in R \wedge j \notin R]$$
	  $$\mathbb{P}[i \in R \wedge j \notin R] = \mathbb{P}[d(i) \leq h < d(j)] = d(j)-d(i)$$
	  Also, from triangle inequality note that 
	  $$d(j) \leq d(i) + y((i,j))$$
	  
	  Hence, $\mathbb{E}[\phi(R)] \leq OBJ$ and therefore, there exists a cut $(U_1,U_2)$, such that $\phi((U_1, U_2)) \leq OBJ$. \\
	  
	  Hence, the dual to the maximum flow problem is a relaxation of the s-t minimum cut problem.
	  
	  \section{Application of Maximum Flow problem in Computer Vision}
	    In this section, we consider the problem of Energy Minimization, which is a problem very well studied in the computer vision community.
	  Following the lines of [insert link to paper], we show how this particular problem can be posed as a maximum flow problem. Hence, this will
	  strengthen the importance of this problem outside the theory community. \\
	  
	  The energy function considered in the computer vision community [Link to grieg, et al paper] is usually represented as :
	  $$E(L) = \displaystyle\sum_{p \in P} D_{p}(L_{p}) + \displaystyle\sum_{(p,q) \in N} V_{p,q}(L_p, L_q)$$
	  where 
	  $L = \{L_p : p \in P\}$ is a labeling of the image P, $D_p$ is a data penalty function, $V_{p,q}$ is an interaction potential, and 
	  $N$ is a set of all pairs of neighboring pixel to the current pixel. \\
	  
	  Assume the case of binary coloring. We want to colour each pixel with either a black or a white label. The graph is constructed as follows:
	  \begin{itemize}
	   \item
	    Each pixel in the image forms a vertex in this graph.
	   \item
	    Additionally, two vertices are added, the vertex corresponding to a black label(s-vertex) and the vertex corresponding to a 
	    white vertex(t-vertex).
	   
	   \item 
	    The edges are classified into two types - the T-links and the N-links.
	    \begin{itemize}
	     \item 
		The N-links are edges among neighboring pixels in the image.
	    The cost of these N-links are the penalty assigned for the discontinuity between the pixels. This can be obtained from the pixel interaction
	    term $V_{p,q}$ in the energy equation.
	    \item
		The T-links, are the edges between the pixel and the terminal node which corresponds to either of
	    the two colours. It signifies the penalty of assigning the label corresponding to the terminal to that pixel. This is obtained from
	    the term $D_p$ in the energy equation.
	    \end{itemize}
	    
	    Any s-t cut partitions the pixels into two disjoint groups. Some vertices present in the same partition as the black label vertex
	    and other vertices present in the same partition as the white label vertex. Hence, for an appropriate setting of the weights based
	    on the parameters of an energy, a minimum s-t cut cost will correspond to a labeling with the minimum value of this energy. [link to
	    that paper]
	    
	    
	  \end{itemize}


	 \chapter{Classical Algorithms}
	  In this chapter, we describe some of the classical algorithms to find the exact value of the maximum flow in an undirected graph. These
	  algorithms have been widely used and give a lot of insight into the nature of the problem. 
	  
	  \section{Ford-Fulkerson Augmenting Path Algorithm}
	    This is the probably the most widely known algorithm for this problem. This algorithm falls into the class of primal-dual algorithms.
	    
	    \begin{program}
	      \mbox{\textbf{Ford-Fulkerson algorithm to compute the maximum flow}}
	      \BEGIN \\ %
		\FOR \text{every edge (i,j)} \in E \DO
		  \text{Initialise f((i,j)) = 0}
		\OD
		\WHILE \exists \text{ a path p from s to t in the residual network } G_f 
		    c_f(p) = \min\{c_f((i,j)): (i,j) \in p\}
		    \FOR \text{each edge (i,j) } \in p \DO
		      \IF (i,j)\in E 
		      \THEN 
			f((i,j)) = f((i,j)) + c_f(p)
		      
		      \ELSE
			f((i,j)) = f((i,j)) - c_f(p)
		      \FI
		    \OD
		 
	      \END
	    \end{program}
	    
	    The running time of this algorithm mostly depends the augmentation method to obtain the residual network. We can show that 
	    for a suitably ill-set of edge capacities, the number of iterations taken by the above algorithm can be very large if the augmenting
	    paths are not chose carefully. Dinic's algorithm precisely solves this part by choosing the shortest augmenting path in each iteration
	    and hence, bounding the overall running time to $O(V^2E)$.
	  
	  \section{Dinic's Algorithm}
	    This algorithm is almost identical to the Ford-Fulkerson algorithm, except for the fact that it chooses the shortest augmenting path using 
	    a Breadth-First search.
	    
	    \begin{program}
	      \mbox{\textbf{Dinic's algorithm to compute the maximum flow}}
	      \BEGIN \\ %
		\FOR \text{every edge (i,j)} \in E \DO
		  \text{Initialise f((i,j)) = 0}
		\OD
		\WHILE \exists \text{ a \textbf{shortest unweighted path p} from s to t in the residual network } G_f 
		    c_f(p) = \min\{c_f((i,j)): (i,j) \in p\}
		    \FOR \text{each edge (i,j) } \in p \DO
		      \IF (i,j)\in E 
		      \THEN 
			f((i,j)) = f((i,j)) + c_f(p)
		      
		      \ELSE
			f((i,j)) = f((i,j)) - c_f(p)
		      \FI
		    \OD
		 
	      \END
	    \end{program}
	    	  
	    The part of the algorithm that is in bold is the only difference between this algorithm and Ford-Fulkerson's algorithm. The advantage 
	    however is that now, the number of residual graphs generated is bounded independent of the edge capacities. \\
	    
	    The above algorithms were the most efficient known for a long time in the literature until, goldberg and others subsequently introduced the 
	    class of algorithms known as the push-relabel algorithms. The algorithms above always maintained edge capacities, while violating the 
	    reservoir capacity at the vertices. Push-relabel algorithms on the other hand, do the converse. In every iteration, the flow is 
	    conserved at every vertex, whereas the edge capacity may be violated. And hence, the algorithm progresses towards ``correcting'' these violations
	    at the edges. \\
	    
	   \section{Push-Relabel Algorithms}
	      In this section, we will describe the general template of any push-relabel algorithm and present a fully recursive specification
	      of the relabel-to-front algorithm. A completely recursive specification hence, allows programmers to directly to adapt it into languages
	      such as prolog. \\
	      
	      
	      \subsubsection{Generic Template of the push-relabel algorithm}
	      In this section we will describe a generic template for any push-relabel algorithm. This is adapted from the text given by 
	      [bibreference to cormen]
	      
	      Associate with every vertex in the graph two parameters, namely potential and reservoir.
	      \begin{itemize}
	       \item 
		  The potential is a measure of knowing the direction in which particular flow should be sent.
	      In some sense, it is used to measure the progress of the algorithm between two iterations of the algorithm.
	      The flow is always sent from a vertex of higher potential to a vertex of lower potential. \\
	      
	      \item
		  The reservoir stores the excessive flow that has been sent to this vertex. Since, in this algorithm the flow conservation is maintained,
		  some flow that has already been sent to this vertex cannot be routed further ahead. Hence, this keeps track of the excessive flow 
		  that accumulates at every vertex. \\
		  
		  
	      \end{itemize}

	      
	      \begin{program}
	            
	      \PROC{INIT\_PREFLOW(G, s):}
	      \BEGIN \\ %
		\FOR \text{every vertex v} \in V \DO
		  potential(v) := 0
		  reservoir(v) := 0
		\OD
		
		\FOR \text{each edge } (i,j) \in E \DO
		  f((i,j)) := 0
		\OD
		
		\text{potential(s)} = n
		
		\FOR \text{each vertex v } \in N(s) \DO
		  f((s,v)) = c((s,v))
		  reservoir(v) = c(s,v)
		  reservoir(s) = reservoir(s) - c((s,v))
		\OD
		
	      \END
	    \end{program}
	      The above procedure initialises the required variables and vectors before the start of the algorithm. \\
	      
	    \textbf{Overflowing vertex} : We say a vertex v is \textit{overflowing}, if the reservoir at vertex $v$ has positive flow accumulated in it,
	    i.e. reservoir(v) $>0$. \\
	    
	    As the name suggests, at every iteration we associate two types of operations, a push operation and the relabel operation.
	    \begin{itemize}
	     \item 
	      \textit{Push operation}: This operation is performed on vertices u and v by pusing some of the accumulated flow at u to vertex v.
	      This is applicable only when the vertex u is overflowing, $c_f((u,v))>0$ and potential(u) = potential(v) + 1. Here, $c_f$ refers to the 
	      capacities in the residual network with respect to the flow f. The operation involves pushing $\min($reservoir(u), $c_f((u,v))$) units of flow
	      from u to v.
	     \item
	      \textit{Relabel}: This operation involves re-assigning the potential of the vertex u. This is applicable only when $u$ is overflowing, and
	      $\forall v \in V$ such that $(u,v) \in E_f$, we have potential(u) $\leq$ potential(v). Here, $E_f$ = $\{(i,j) \in E : f((i,j)) < c((i,j))\}$.
	      The operation involves re-assigning the potential of this vertex u with one more than the minimum of all such $v$.
	    \end{itemize}
	    
	    \begin{program}
	      \mbox{\textbf{Push Operation}}
	      
	      \PROC{PUSH(u, v):}
	      \BEGIN \\ %
		\Delta_f((u,v)) = \min(\text{reservoir(u)}, c_f((u,v)))
		
		\IF (u,v) \in E_f
		  \THEN
		    f((u,v)) = f((u,v)) + \Delta_f((u,v))
		  \ELSE
		    f((v,u)) = f((v,u)) - \Delta_f((u,v))
		\FI
		
		\text{reservoir(u) = reservoir(u)} - \Delta_f((u,v))
		\text{reservoir(v) = reservoir(v)} + \Delta_f((u,v))
	      \END
	    \end{program}
	    
	    \begin{program}
	      \mbox{\textbf{Relabel Operation}}
	      
	      \PROC{RELABEL(u):}
	      \BEGIN \\ %
		\text{potential(u) = } 1 + \min \{\text{potential(v)} : (u,v) \in E_f \}
	      \END
	    \end{program}
	    
	    With the above two functions available, a generic push-relabel algorithm looks as follows:
	    
	    \begin{program}
	      \mbox{\textbf{Push Relabel Template}}
	      
	      \PROC{MAX-FLOW(G, s, t):}
	      \BEGIN \\ %
		\text{INIT\_FLOW(G, s)}
		\WHILE \text{exists an applicable push or relabel operation} \DO
		   \text{Call the appropriate push or relabel operation} 
		 \OD
	      \END
	    \end{program}

	    The proof of correctness of this algorithm can be shown by using the potential function on the vertices. We omit the proof here. The 
	    reader is encouraged to read [bib to cormen] for more details. \\
	    	    
	    Based on the specific implementation of the template i.e. the order of push and relabel operations performed, we can bound the running time 
	    of the algorithm. In the following sub-section, we give a fully recursive specification of the relabel-to-front algorithm and bound the 
	    running time of this algorithm. \\
	    
	    
	    
	   \section{Goldberg-Rao Blocking Flow Algorithm}
	    In this section, we briefly describe the idea behind the goldberg-rao's algorithm. The description of this algorithm is adapted from 
	    [link to the lecture notes containing the algorithm] \\
	    
	    Before describing the main algorithm, let us first have some definitions in place. \\
	    
	    \textbf{Delta indicator}: We define a vector $L$, which is a delta indicator for a particular flow f i.e.
	    \[ L((i,j)) = \left\{ 
	      \begin{array}{l l}
	      1 & \quad u_f((i,j)) \leq \Delta\\
	      0 & \quad \text{otherwise}
	      \end{array} \right.\]
	    
	    
	    \textbf{Admissible Edge}: We call an edge $(i, j) \in E_f$ admissible with respect to the flow f, if dist(i) = dist(j) + $L_f$((i,j)). Here,
	    the dist(v) refers to the shortest distance of vertex v to sink t. \\
	    
	    \textbf{Blocking flow}: A flow f is \textit{blocking} if every s-t path in the graph G has atleast one completely saturated edge. \\
	    
	    \begin{program}
	      \mbox{\textbf{Goldberg-Rao Algorithm}}
	      
	      \PROC{Goldberg-Rao(G, s, t):}
	      \BEGIN \\ %
		\text{Initialise F as mU, where U = } \displaystyle\max_{(i,j) \in E} u((i,j))
		\text{Initialise f as 0}
		\text{Define } \varLambda \text{ as } \min(m^{\frac{1}{2}}, n^{\frac{2}{3}})
		
		\WHILE F \geq 1 \DO
		  \text{Assign } \Delta \text{ as } \frac{F}{2 \ast \varLambda}
		  
		  \FOR i:=1 \TO 5 \ast \varLambda \DO
		    \text{- Compute the Delta indicator vector L}
		    \text{- Compute dist(i), using the vector L as the vector of edge lengths}
		    \text{- Shrink the strongly-connected components of admissible edges}
		    \text{- Find a flow }\tilde{f} \text{ in the shrunken graph s.t. it is either a blocking flow or value of the flow is }
		    \frac{\Delta}{4}
		    \text{- Assign } \bar{f} \text{ as }\tilde{f} \text{ with the flows completely routed within the edges of the }
		    \text{shrunken components.}
		    \text{ - }f = f + \bar{f}
		  \OD
		  F = \frac{F}{2}
		\OD
	      \END
	    \end{program}
	    
	    In the above algorithm, \textit{shrinking} a strongly connected component(SCC) means, replacing the entire SCC by a 
	    single vertex, whose incoming edges are the incoming edges of all vertices of the SCC, and whose outgoing edges
	    are outgoing edges of all vertices of the SCC. \\
	    
	    As again, we encourage the reader to refer to [link to the notes] for a complete analysis of the correctness of the above algorithm
	    and its running time.
	 \chapter{Spectral Graphs}
	 
	 \chapter{Cristiano-Kelner-Madry-Spielman-Teng Algorithm}
	 
	 
	
    \chapter{A SAMPLE APPENDIX}
 
 Just put in text as you would into any chapter with sections and
 whatnot.  Thats the end of it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% List of papers

\chapter*{Publications}
\vspace{-0.3cm}

\begin{enumerate}
\item S. M. Narayanamurthy and B. Ravindran (2007). \newblock
  Efficiently Exploiting Symmetries in Real Time Dynamic Programming. \newblock {\em
  IJCAI 2007, Proceedings of the 20th International Joint Conference on
  Artificial Intelligence}, pages 2556--2561.
\end{enumerate}

%\nocite{bellman, Amarel:1968, manning, knoblock90learning,
%crawford92theoretical, Barto:rtdp, Ravindran:proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography.
\pagebreak
\begin{singlespace}
  \begin{small}
	\bibliography{refs}
  \end{small}
\end{singlespace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
